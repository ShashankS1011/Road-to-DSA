# Data Structures and Algorithms (DSA) Repository
Welcome to the Data Structures and Algorithms (DSA) repository! This repository is a comprehensive resource for learning and practicing data structures and algorithms in computer science.
## Introduction
Data structures and algorithms are fundamental concepts in computer science that are essential for solving complex problems efficiently. Whether you are a beginner looking to learn the basics or an experienced developer wanting to brush up on your skills, this repository is designed to help you understand and implement various data structures and algorithms.
## Contents
This repository covers a wide range of data structures and algorithms, including but not limited to:

### Data Structures:
- Arrays
- Linked Lists
- Stacks
- Queues
- Trees (Binary Trees, AVL Trees, etc.)
- Graphs
- Hash Tables
- Heaps

### Algorithms:

- Sorting Algorithms (Bubble Sort, Merge Sort, Quick Sort, etc.)
- Searching Algorithms (Linear Search, Binary Search, etc.)
- Graph Algorithms (Depth-First Search, Breadth-First Search, Dijkstra's Algorithm, etc.)
- Dynamic Programming
- Divide and Conquer
- Greedy Algorithms



## What is Data Structure?
A data structure can be described as a specific method for efficiently storing and organizing data within our devices. The primary objective of using data structures is to optimize time and space complexities. An efficient data structure minimizes memory usage and reduces execution time for data manipulation.

## What is an Algorithm?
An algorithm is a defined process or a set of well-defined instructions commonly employed to solve a particular set of problems or perform specific calculations. In simpler terms, it consists of a series of steps performed sequentially to accomplish a task.

## How to Start Learning DSA?
Learning Data Structures and Algorithms (DSA) effectively involves breaking down the overall learning process into smaller, sequential steps. Here's a structured approach:

#### 1. Understanding Time and Space Complexities:
Begin by grasping the concepts of time and space complexities. These fundamental ideas are essential for assessing the efficiency of algorithms and data structures.

#### 2. Learning the Basics of Individual Data Structures: 
Focus on gaining a solid understanding of various data structures such as arrays, linked lists, stacks, queues, trees, graphs, hash tables, and heaps. Learn how to implement and use them effectively.

#### 3. Learning the Basics of Algorithms: 
Study different algorithms like sorting algorithms (e.g., Bubble Sort, Merge Sort, Quick Sort), searching algorithms (e.g., Linear Search, Binary Search), graph algorithms (e.g., Depth-First Search, Breadth-First Search), dynamic programming, divide and conquer, and greedy algorithms. Understand their principles, advantages, and use cases.

#### 4. Practice Problems on DSA: 
Apply your knowledge by solving problems related to data structures and algorithms. Start with simple problems and gradually progress to more complex ones. Practice on online platforms, participate in coding competitions, and analyze solutions to enhance your problem-solving skills.


### Classification:
Data structures can be classified into two broad categories:

- **Linear Data Structure:** A data structure in which data elements are arranged sequentially or linearly, where each element is attached to its previous and next adjacent elements, is called a linear data structure. Examples are array, stack, queue.
   - **Static data structure:** Static data structure has a fixed memory size. It is easier to access the elements in a static data structure. An example of this data structure is an array.
   - **Dynamic data structure:** In the dynamic data structure, the size is not fixed. It can be randomly updated during the runtime which may be considered efficient concerning the memory (space) complexity of the code. Examples of this data structure are queue, stack.
- **Non-linear Data Structure:** Data structures where data elements are not placed sequentially or linearly are called non-linear data structures. Examples are trees and graphs.

### Applications of Data Structures:
- **Databases:** Data structures play a crucial role in organizing and storing data within databases, enabling efficient retrieval and manipulation of information.
- **Operating Systems:** Data structures are integral to the design and implementation of operating systems. They help manage system resources like memory and files.
- **Computer Graphics:** Data structures are employed to represent various graphical elements, such as geometric shapes, in computer graphics applications.
- **Artificial Intelligence:** Data structures are utilized to represent knowledge and information within artificial intelligence systems, facilitating data management and processing.

### Advantages of Data Structures:
- **Efficiency:** Data structures enable efficient storage and retrieval of data, particularly crucial in performance-critical applications.
- **Flexibility:** Data structures provide a flexible means to organize and store data, simplifying modifications and manipulations as needed.
- **Reusability:** Data structures can be reused across multiple programs and applications, reducing redundancy and promoting code efficiency.
- **Maintainability:** Well-designed data structures enhance program understandability, ease of modification, and long-term maintainability.



| Aspect | Data Type | Data Structure |
|----------|----------|----------|
|Definition|A data type defines the type of data that a variable or object can hold. It specifies the nature of the data, such as integer, float, character, etc. |	A data structure defines how data is organized, stored, and accessed. It specifies the relationship and arrangement of data elements. |
|Scope|	Data types are typically used to define the attributes of individual variables or objects.|	Data structures are used to organize and manage collections of data elements, often with a specific purpose |application in mind.|
|Examples|	- int (integer) <br> - float (floating-point number) <br> - char (character)|	- Array <br> - Linked List <br> - Stack <br> - Queue <br> - Tree <br> - Graph <br> - Hash Table|
|Purpose|	Data types ensure that variables or objects are correctly used and can help prevent type-related errors in programming.|	Data structures provide a way to store and manage collections of data efficiently, allowing for operations like insertion, deletion, and retrieval.|
|Granularity|	Data types are concerned with individual variables and their values.|	Data structures deal with the arrangement and relationships among multiple data elements.|


## Algorithms
A procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations.

## Use of the Algorithms:
Algorithms play a crucial role in various fields and have many applications. Some of the key areas where algorithms are used include:

1. **Computer Science:** Algorithms form the basis of computer programming and are used to solve problems ranging from simple sorting and searching to complex tasks such as artificial intelligence and machine learning.
2. **Mathematics:** Algorithms are used to solve mathematical problems, such as finding the optimal solution to a system of linear equations or finding the shortest path in a graph.
3. **Operations Research:** Algorithms are used to optimize and make decisions in fields such as transportation, logistics, and resource allocation.
4. **Artificial Intelligence:** Algorithms are the foundation of artificial intelligence and machine learning, and are used to develop intelligent systems that can perform tasks such as image recognition, natural language processing, and decision-making.


## Types of Algorithms:
There are several types of algorithms available. Some important algorithms are:

### 1. Brute Force Algorithm:
It is the simplest approach to a problem. A brute force algorithm is the first approach that comes to finding when we see a problem.

### 2. Recursive Algorithm:
A recursive algorithm is based on recursion. In this case, a problem is broken into several sub-parts and called the same function again and again.

### 3. Backtracking Algorithm:
The backtracking algorithm builds the solution by searching among all possible solutions. Using this algorithm, we keep on building the solution following criteria. Whenever a solution fails we trace back to the failure point build on the next solution and continue this process till we find the solution or all possible solutions are looked after.

### 4. Searching Algorithm:
Searching algorithms are the ones that are used for searching elements or groups of elements from a particular data structure. They can be of different types based on their approach or the data structure in which the element should be found.

### 5. Sorting Algorithm:
Sorting is arranging a group of data in a particular manner according to the requirement. The algorithms which help in performing this function are called sorting algorithms. Generally sorting algorithms are used to sort groups of data in an increasing or decreasing manner.

### 6. Hashing Algorithm:
Hashing algorithms work similarly to the searching algorithm. But they contain an index with a key ID. In hashing, a key is assigned to specific data.

### 7. Divide and Conquer Algorithm:
This algorithm breaks a problem into sub-problems, solves a single sub-problem, and merges the solutions to get the final solution. It consists of the following three steps:

- Divide
- Solve
- Combine
  
### 8. Greedy Algorithm:
In this type of algorithm, the solution is built part by part. The solution for the next part is built based on the immediate benefit of the next part. The one solution that gives the most benefit will be chosen as the solution for the next part.

### 9. Dynamic Programming Algorithm:
This algorithm uses the concept of using the already found solution to avoid repetitive calculation of the same part of the problem. It divides the problem into smaller overlapping subproblems and solves them.

### 10. Randomized Algorithm:
In the randomized algorithm, we use a random number so it gives immediate benefit. The random number helps in deciding the expected outcome.

## Advantages of Algorithms:
- It is easy to understand.
- An algorithm is a step-wise representation of a solution to a given problem.
- In an Algorithm the problem is broken down into smaller pieces or steps hence, it is easier for the programmer to convert it into an actual program.
  
## Disadvantages of Algorithms:
- Writing an algorithm takes a long time so it is time-consuming.
- Understanding complex logic through algorithms can be very difficult.
- Branching and Looping statements are difficult to show in Algorithms(imp).



## Introduction to Arrays
### What is an Array?
An array is a collection of items of same data type stored at contiguous memory locations. 

### Operations Performed on Array
#### Search Operation:
In an unsorted array, the search operation can be performed by linear traversal from the first element to the last element. 

#### Insert Operation:
1. Insert at the end.
2. Insert at any position.
3. Delete.


### Applications of Array Data Structure:

Below are some applications of arrays.

- **Storing and accessing data:** Arrays are used to store and retrieve data in a specific order. For example, an array can be used to store the scores of a group of students, or the temperatures recorded by a weather station.
- **Sorting:** Arrays can be used to sort data in ascending or descending order. Sorting algorithms such as bubble sort, merge sort, and quicksort rely heavily on arrays.
- **Searching:** Arrays can be searched for specific elements using algorithms such as linear search and binary search.
- **Matrices:** Arrays are used to represent matrices in mathematical computations such as matrix multiplication, linear algebra, and image processing.
- **Stacks and queues:** Arrays are used as the underlying data structure for implementing stacks and queues, which are commonly used in algorithms and data structures.
- **Graphs:** Arrays can be used to represent graphs in computer science. Each element in the array represents a node in the graph, and the relationships between the nodes are represented by the values stored in the array.
- **Dynamic programming:** Dynamic programming algorithms often use arrays to store intermediate results of subproblems in order to solve a larger problem.
  
### Real-Time Applications of Array:

Below are some real-time applications of arrays.

- **Signal Processing:** Arrays are used in signal processing to represent a set of samples that are collected over time. This can be used in applications such as speech recognition, image processing, and radar systems.
- **Multimedia Applications:** Arrays are used in multimedia applications such as video and audio processing, where they are used to store the pixel or audio samples. For example, an array can be used to store the RGB values of an image.
- **Data Mining:** Arrays are used in data mining applications to represent large datasets. This allows for efficient data access and processing, which is important in real-time applications.
- **Robotics:** Arrays are used in robotics to represent the position and orientation of objects in 3D space. This can be used in applications such as motion planning and object recognition.
- **Real-time Monitoring and Control Systems:** Arrays are used in real-time monitoring and control systems to store sensor data and control signals. This allows for real-time processing and decision-making, which is important in applications such as industrial automation and aerospace systems.


### Advantages of Structure over Array:

- The structure can store different types of data whereas an array can only store similar data types.
- Structure does not have limited size like an array.
- Structure elements may or may not be stored in contiguous locations but array elements are stored in contiguous locations.
- In structures, object instantiation is possible whereas in arrays objects are not possible.


## Strings
A String can also be defined as a sequence of characters, stored in contiguous memory locations, terminated by a special character called the null character ‘\0’. 

### Characteristics of String:
In the context of Data Structures and Algorithms, strings have the following properties:

- Ordered: Strings are ordered sequences of characters, where each character has a unique position in the string.
- Indexable: Strings can be indexed, meaning that individual characters within a string can be accessed using a numerical index.
- Comparable: Strings can be compared to each other to determine their relative order or equality.

### Advantages of String: 
- **Widely Supported:** Strings are a fundamental data type in most programming languages, making them widely available and well-supported.
- **Efficient Manipulation:** Many algorithms and data structures have been developed to efficiently manipulate strings, such as string matching algorithms, string compression algorithms, and data structures like tries and suffix arrays.
- **Ability to Model Real-World Data:** Strings are often used to model real-world data, such as names, addresses, and other forms of text data, making them a useful tool in many applications.
- **Text Mining and Natural Language Processing:** Strings are used as input to algorithms for text mining and natural language processing, such as sentiment analysis and named entity recognition.

### Disadvantages of String:
- **Encoding Issues:** Strings can be represented in different encodings, such as UTF-8 or UTF-16, which can cause compatibility issues when processing strings from different sources.
- **Immutable:** Strings are often implemented as immutable data structures, meaning that once a string has been created, it cannot be modified. This can lead to additional overhead when manipulating strings, as new strings must be created for every modification.
- **Slow Concatenation:** Concatenating strings can be slow, as it requires creating a new string and copying all of the characters from the original strings into the new string.

### Operations Performed on a String:
- Accessing characters by index in a string.
- Inserting character into a String.
- Modifying character in String
- Deletion of Character in String
- Concatenating strings (combining multiple strings into one).
- Finding the length of a string
- Comparing strings for equality or lexicographical order


## Stack
A stack is defined as a linear data structure that is open at one end and the operations follow the Last-In-First-Out (LIFO) order.

### Characteristics of  Stack:
- The stack follows the LIFO order, which means that the last element added to the stack will be the first element to be removed.
- A register that points to the top of the stack is known as the stack pointer. It is used to keep track of the current position of the top of the stack.
- A stack is also characterized by its capacity, which is the maximum number of elements it can hold at any given time. If an attempt is made to push an element onto a full stack, a stack overflow error will occur.


### Advantages of Stack:
- Stacks are simple to implement and can be created using arrays, linked lists, or even dynamic memory allocation.
- Stacks are efficient in memory management as they only allocate memory for the elements that are currently in the stack.
- The push and pop operations have O(1) time complexity, which means that take constant time regardless of the size of the stack.
- To learn more about the advantages of the stack, refer to this article.

### Disadvantages of Stack:
- Static stacks have a fixed size, which means that in a stack we can add limited elements.
- Stacks can suffer from overflow when you try to add more elements than the stack size, and underflow when you try to remove an element from an empty stack.
- Stacks can only be used to store and retrieve data in a specific order, whereas queues and trees can be used to store and retrieve data in a variety of orders.


### Operations Performed on Stacks
- push() to insert an element into the stack
- pop() to remove an element from the stack
- top() Returns the top element of the stack.
- isEmpty() returns true if the stack is empty else false.
- size() returns the size of the stack.

### Types of Stacks:

- **Register Stack:** This type of stack is also a memory element present in the memory unit and can handle a small amount of data only. The height of the register stack is always limited as the size of the register stack is very small compared to the memory.
- **Memory Stack:** This type of stack can handle a large amount of memory data. The height of the memory stack is flexible as it occupies a large amount of memory data.


## Queue
A Queue is defined as a linear data structure that is open at both ends and the operations are performed in First In First Out (FIFO) order.

### Queue Representation:
Like stacks, Queues can also be represented in an array: In this representation, the Queue is implemented using the array. Variables used in this case are

- Queue: the name of the array storing queue elements.
- Front: the index where the first element is stored in the array representing the queue.
- Rear: the index where the last element is stored in an array representing the queue.

### FIFO Principle of Queue:
- A Queue is like a line waiting to purchase tickets, where the first person in line is the first person served. (i.e. First come first serve).
- Position of the entry in a queue ready to be served, that is, the first entry that will be removed from the queue, is called the front of the queue(sometimes, head of the queue), similarly, the position of the last entry in the queue, that is, the one most recently added, is called the rear (or the tail) of the queue. See the below figure.

## Operations Performed on Queue
The queue operations are as follows:

- create
- enqueue
- dequeue
- isEmpty
- isFull
- size
  
1) create :  Creates and initializes new queue that is empty, it does not require any parameter and returns an empty queue.
2) enqueue:  Add a new element to the rear of queue . It requires the element to be added and returns nothing.
3) dequeue:  removes the elements from the front of queue. It does not require any parameters and returns the deleted item.
4) isEmpty: Check the whether the queue is empty or not. It does not require any parameter and returns a Boolean value.


| Stack | Queue |
|---------|--------|
| A stack is a data structure that stores a collection of elements, with operations to push (add) and pop (remove) elements from the top of the stack.|	A queue is a data structure that stores a collection of elements, with operations to enqueue (add) elements at the back of the queue, and dequeue (remove) elements from the front of the queue. |
| Stacks are based on the LIFO principle, i.e., the element inserted at the last, is the first element to come out of the list.|	Queues are based on the FIFO principle, i.e., the element inserted at the first, is the first element to come out of the list.|
| Stacks are often used for tasks that require backtracking, such as parsing expressions or implementing undo functionality.|	Queues are often used for tasks that involve processing elements in a specific order, such as handling requests or scheduling tasks.|
| Insertion and deletion in stacks takes place only from one end of the list called the top.| Insertion and deletion in queues takes place from the opposite ends of the list. The insertion takes place at the rear of the list and the deletion takes place from the front of the list.|
| Insert operation is called push operation.|	Insert operation is called enqueue operation.|
| Stacks are implemented using an array or linked list data structure.|	Queues are implemented using an array or linked list data structure.|
| Delete operation is called pop operation.|	Delete operation is called dequeue operation.|
| In stacks we maintain only one pointer to access the list, called the top, which always points to the last element present in the list.|	In queues we maintain two pointers to access the list. The front pointer always points to the first element inserted in the list and is still present, and the rear pointer always points to the last inserted element.|
| Stack is used in solving problems works on recursion.|	Queue is used in solving problems having sequential processing.|
| Stacks are often used for recursive algorithms or for maintaining a history of function calls.|	Queues are often used in multithreaded applications, where tasks are added to a queue and executed by a pool of worker threads.|
| Stack does not have any types.|	Queue is of three types – 1. Circular Queue 2. Priority queue 3. double-ended queue.|
| Can be considered as a vertical collection visual.|	Can be considered as a horizontal collection visual.|
| Examples of stack-based languages include PostScript and Forth.|	Examples of queue-based algorithms include Breadth-First Search (BFS) and printing a binary tree level-by-level.|

### Applications of queue:
- Queue data structure is implemented in the hardware microinstructions inside a CPU.
- Queue structure is used in most operating systems.
